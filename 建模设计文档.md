# 票据配票优化建模设计文档

## 1. 业务问题与建模目标
票据配票问题可以抽象为一个带多维偏好约束的组合优化问题。当不允许拆分票据时，可视为带复杂偏好排序的 0/1 背包；允许拆分后则演化为部分背包（Fractional Knapsack）的扩展版。目标是在票据池中选出不超过张数上限的票据组合，使得组合金额与付款单金额 \(M\) 尽可能接近，并同时兼顾期限、承兑人、组织归属及库存平衡等偏好维度。

## 2. 符号体系与输入参数
### 2.1 集合定义
- \(I\)：票据池中全部票据的索引集合。
- \(I_M\subseteq I\)：预筛选后保留的候选票据集合。

### 2.2 输入参数
- \(M\)：付款单金额，单位为元。
- \(A_i\)：票据 \(i\) 的原始面额。
- \(A^\text{cat}_i\)：票据 \(i\) 所属的金额类型（大票/中票/小票）。
- \(D_i\)：票据 \(i\) 距离到期的天数。
- \(C_i\)：承兑人评分或等级，可映射为数值。
- \(O_i\)：票据 \(i\) 的所属组织。
- \(\text{org}_p\)：付款单所属组织。
- \(w_1, w_2, w_3, w_4\)：四个偏好维度的权重，满足 \(\sum_k w_k = 1\)。
- \(\text{tail}\)：尾差阈值，按类型可理解为金额上限或金额比例。
- \(S_{\max}\)：单笔交易可用票据张数上限。
- \(A_{\min}, A_{\max}\)：单票使用金额的下界与上界。
- \(N_{\min}\)：允许使用的极小金额票据数量上限。
- 库存结构信息：库存占比 \(p_c\)、目标余票占比 \(e_c\)。
- 用户偏好：`prefer_exact`、`allow_split`、`allow_inventory_balance`、金额/库存区间配置。

## 3. 决策变量设计
- \(x_i\in\{0,1\}\)：若票据 \(i\) 被纳入组合则取 1，否则为 0。
- \(y_i\ge 0\)：票据 \(i\) 实际使用金额，若未入选则 \(y_i = 0\)。
- \(s_i\ge 0\)：票据 \(i\) 拆分后留存金额，未拆分则 \(s_i = 0\)。
- \(z^{\text{split}}\)：是否触发拆票操作的指示变量（实现中通过逻辑判断完成）。

## 4. 约束体系
1. **金额范围与张数控制**
\[
\sum_{i\in I} y_i \le M + \text{tail}, \quad \sum_{i\in I} y_i \ge M - \text{tail}
\]
\[
\sum_{i\in I} \mathbb{1}[y_i > 0] \le S_{\max}
\]

2. **单票金额上下界**
\[
A_{\min} \le y_i \le A_{\max},\quad \forall i \text{ with } y_i > 0
\]

3. **拆票留存约束**（若允许拆票）
\[
s_i = A_i - y_i,\quad s_i = 0 \text{ 或 } s_i \ge \text{remain\_after\_split}
\]

4. **极小金额票据控制**
\[
\sum_{i\in I} \mathbb{1}[y_i < 2A_{\min}] \le N_{\min}
\]

5. **库存平衡偏好**（可选）
保证拆出组合后剩余库存与目标占比的偏差在可接受范围内：
\[
\left| p_c^{\text{remaining}} - e_c \right| \le \epsilon_c, \quad c \in \{\text{大}, \text{中}, \text{小}\}
\]
这些约束在当前实现中通过评分惩罚而非硬约束实现。

## 5. 目标函数设计
采用加权评分模型综合衡量金额贴合度与多维偏好：
\[
\max \Big( w_1 \cdot f_\text{amount} + w_2 \cdot f_\text{term} + w_3 \cdot f_\text{acceptor} + w_4 \cdot f_\text{organization} \Big)
\]

- \(f_\text{amount}\)：金额贴合度。分为金额策略子模式，包括大额优先、小额优先、接近但小于 \(M\)、接近但大于 \(M\)、库存优化等。
- \(f_\text{term}\)：期限偏好评分，按照“优先远”或“优先近”进行归一化。
- \(f_\text{acceptor}\)：承兑人偏好评分，按优先好/差进行映射。
- \(f_\text{organization}\)：组织偏好评分，关注是否与付款单同组织或跨组织。
- 库存平衡开启时，再以 0.2 的权重叠加库存匹配得分，体现软约束。

## 6. 分层求解策略
1. **快速预筛选** (`_fast_prefilter`)
   - 依据金额上下界、金额策略与综合评分对票据池进行裁剪，控制候选集规模在 1000 张以内。
2. **改进贪心构建** (`_improved_greedy_construct`)
   - 按综合评分排序，分三轮（严格、适度、宽松）尝试加入票据，确保在允许的误差区间内逼近目标金额，同时满足张数与极小金额票限制。
3. **局部优化阶段**
   - **拆票优化** (`_optimize_split`、`_split_from_pool`、`_split_from_current`): 当差额超出尾差阈值时触发，优先选择金额最合适、满足留存约束的票据拆分。
   - **交换优化** (`_swap_optimization`): 尝试用未使用的高分票据替换组合内得分较低的票据，以提升综合得分。
   - **库存微调** (`_balance_inventory`): 可选步骤，在开启库存平衡偏好时微调组合以降低库存偏差。

## 7. 拆票子模型
- 计算差额 \(\text{bias} = M - \sum_i y_i\)。
- 若 \(0 < \text{bias} < \text{tail}\)，可通过电汇补齐；否则需从未使用票据中选择金额大于差额的票据进行拆分。
- 若 \(\text{bias} < 0\)，从已选票据中挑选一张拆分，使得调整后金额重新落入目标区间，并保证剩余留存金额满足阈值。
- 拆票选择策略可沿用金额、期限或承兑人维度的排序偏好。

## 8. 权重与得分计算逻辑
- 金额策略 (`AmountStrategy`) 映射到不同的评分函数：
  - 大额优先/小额优先：使用线性归一化的顺序评分。
  - 接近但小于/大于 \(M\)：对目标差距进行片段函数设计。
  - 库存优化：基于当前库存与目标库存的偏差计算各类型优先级。
- 期限、承兑人、组织评分均通过归一化或布尔映射实现。
- 库存匹配得分依据拆出组合后剩余库存与目标占比的差距计算（见 `_calc_inventory_balance_score_for_solution`）。

## 9. 可行性保障与约束检查
- 预筛选阶段确保候选票据满足金额区间、单票上下限等硬约束。
- 贪心选取过程中同步维护张数、极小票计数，并在金额越界时分轮次扩展。
- 拆票函数在拆分前会检查尾差、留存金额、单票金额上下界，若不满足则回退或切换策略。
- 交换优化时确保替换后总金额偏差不超过当前 1.5 倍，维持金额可行性。

## 10. 复杂度与效率
- 预筛选主要成本为排序，复杂度约 \(O(N \log N)\)。
- 贪心阶段最多遍历筛后 1000 张票据 3 轮，复杂度 \(O(3000)\)。
- 拆票与交换优化在候选集上进行局部搜索，控制迭代次数（默认 50 次）以平衡精度与效率。
- 整体流程适用于 7k~10k 规模的票据池，能够在秒级完成优化。

## 11. 代码实现映射
- 数据结构定义：`optimized_ticket_matcher.py` 中的 `Ticket`、`PaymentOrder`、`UserPreference`、`TargetWeights`、`SplitRule`、`Constraints`、`InventoryInfo`、`Solution`、`TicketUsageDetail`。
- 核心流程：`OptimizedTicketMatcher.optimize` 依次调用 `_fast_prefilter` → `_improved_greedy_construct` → `_optimize_split` → `_swap_optimization` → `_balance_inventory`。
- 拆票逻辑：`_optimize_split` 负责触发，`_split_from_pool` 与 `_split_from_current` 执行具体分割策略。
- 得分计算：`_compute_scores` 及 `_calc_solution_score` 负责维度评分与综合得分。
- 示例与测试：`run_example`、`test_correct_split.py`、`test_split_fix.py`、`test_split_output.py` 覆盖了典型拆票与输出场景。

## 12. 后续扩展建议
- 将库存平衡从软约束扩展为可调惩罚系数的拉格朗日松弛项，以增强可控性。
- 引入多线程或并行化评分计算，加速大规模票据池预处理。
- 进一步量化拆票策略（例如引入混合整数规划或遗传算法备选方案）以强化在极端场景下的最优性保障。
